<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Natal Chart Calculator â€¢ 3D Astrology</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS2DRenderer.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { margin:0; overflow:hidden; background:#0a0a0f; font-family:system-ui,sans-serif; }
  #viewer { position:absolute; inset:0; }
  #sidebar { position:absolute; left:0; top:0; bottom:0; width:380px; background:rgba(15,15,30,0.96); backdrop-filter:blur(12px); border-right:1px solid #333; overflow-y:auto; z-index:10; padding:24px; }
  #chart-overlay { position:absolute; right:20px; top:20px; width:360px; min-width:300px; max-width:90vw; background:rgba(15,15,30,0.96); backdrop-filter:blur(12px); border:1px solid #444; border-radius:12px; padding:20px; z-index:10; max-height: calc(100vh - 40px); overflow-y:auto; resize: both; overflow: auto; }
  #chart-header { cursor: move; user-select: none; padding-bottom: 10px; border-bottom: 1px solid #333; margin-bottom: 10px; }
  #chart-header:active { cursor: grabbing; }
  .label { pointer-events:none; font-weight:bold; text-shadow:0 0 8px #000, 0 0 12px #000; white-space:nowrap; font-size:21px; color:#f0f0ff; }
  button.on { background-color:#6366f1 !important; color:white; }
  button.off { background-color:#4b5563 !important; color:white; }
  input, select { background: #1a1a2e; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 6px; width: 100%; }
  input:focus, select:focus { outline: none; border-color: #6366f1; }
  .section-title { font-size: 14px; font-weight: 600; color: #8899ff; margin-top: 16px; margin-bottom: 8px; }
  
  #astro-chart { position: relative; width: 320px; height: 320px; margin: 0 auto; }
  .chart-circle { position: absolute; border-radius: 50%; border: 2px solid #5577aa; }
  .chart-wheel { width: 320px; height: 320px; top: 0; left: 0; }
  .chart-inner { width: 210px; height: 210px; top: 55px; left: 55px; border-color: #667799; }
  .house-line { position: absolute; width: 2px; height: 160px; background: #667799; top: 0; left: 159px; transform-origin: 1px 160px; opacity: 0.5; }
  .asc-line { background: #ff6b6b !important; opacity: 0.8 !important; width: 3px !important; }
  .mc-line { background: #4ade80 !important; opacity: 0.8 !important; width: 3px !important; }
  .planet-marker { position: absolute; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; background: rgba(0,0,0,0.8); border: 2px solid; transform: translate(-50%, -50%); z-index: 10; cursor: pointer; transition: transform 0.2s; }
  .planet-marker:hover { transform: translate(-50%, -50%) scale(1.15); }
  .planet-degree { position: absolute; font-size: 9px; color: #aaa; margin-top: 34px; white-space: nowrap; left: 50%; transform: translateX(-50%); }
  .sign-label { position: absolute; font-size: 13px; color: #99aacc; font-weight: bold; transform: translate(-50%, -50%); }
  .house-number { position: absolute; font-size: 11px; color: #7788aa; font-weight: bold; transform: translate(-50%, -50%); }
  .mode-indicator { display: inline-block; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; margin-left: 8px; }
  .mode-live { background: #10b981; color: white; }
  .mode-natal { background: #f59e0b; color: white; }
  .aspect-line { position: absolute; top: 160px; left: 160px; transform-origin: 0 0; height: 2px; pointer-events: none; }
  .aspect-conjunction { background: #fbbf24; opacity: 0.6; }
  .aspect-opposition { background: #ef4444; opacity: 0.6; }
  .aspect-trine { background: #10b981; opacity: 0.6; }
  .aspect-square { background: #f97316; opacity: 0.6; }
  .aspect-sextile { background: #3b82f6; opacity: 0.6; }
  .aspect-item { font-size: 11px; padding: 4px 8px; margin: 2px 0; border-radius: 4px; background: rgba(100,100,100,0.3); }
  .tooltip { position: absolute; background: rgba(0,0,0,0.9); color: white; padding: 8px 12px; border-radius: 6px; font-size: 11px; pointer-events: none; z-index: 1000; display: none; }
  .preset-btn { font-size: 11px; padding: 6px 10px; margin: 2px; border-radius: 4px; background: #374151; cursor: pointer; }
  .preset-btn:hover { background: #4b5563; }
</style>
</head>
<body class="text-gray-200">

<div id="sidebar">
  <h1 class="text-2xl font-bold mb-1 text-center">Natal Chart Calculator</h1>
  <p class="text-gray-400 text-center text-sm mb-4">3D Astrological Visualization</p>

  <!-- Birth Data Input -->
  <div class="bg-gray-800/50 p-4 rounded-lg mb-3">
    <h3 class="font-bold text-lg mb-3">Birth Information</h3>
    
    <div class="flex gap-2 mb-3 flex-wrap">
      <button class="preset-btn" onclick="loadPreset('current')">Now</button>
      <button class="preset-btn" onclick="loadPreset('example1')">Example 1</button>
      <button class="preset-btn" onclick="loadPreset('example2')">Example 2</button>
    </div>
    
    <label class="block text-sm text-gray-400 mb-1">Date of Birth</label>
    <input type="date" id="birth-date" class="mb-2" value="1990-01-01">
    
    <label class="block text-sm text-gray-400 mb-1">Time of Birth</label>
    <input type="time" id="birth-time" class="mb-2" value="12:00">
    
    <label class="block text-sm text-gray-400 mb-1">Location</label>
    <input type="text" id="birth-location" placeholder="City, Country" class="mb-2">
    
    <div class="grid grid-cols-2 gap-2 mb-3">
      <div>
        <label class="block text-xs text-gray-400 mb-1">Latitude</label>
        <input type="number" id="birth-lat" step="0.0001" placeholder="40.7128" class="text-sm">
      </div>
      <div>
        <label class="block text-xs text-gray-400 mb-1">Longitude</label>
        <input type="number" id="birth-lon" step="0.0001" placeholder="-74.0060" class="text-sm">
      </div>
    </div>
    
    <button id="calculate-natal" class="w-full py-3 px-4 rounded font-medium bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 transition">
      Calculate Natal Chart
    </button>
    
    <button id="show-now" class="w-full mt-2 py-2 px-4 rounded font-medium bg-gray-700 hover:bg-gray-600 transition text-sm">
      Show Current Transits
    </button>
  </div>

  <!-- Current Mode Display -->
  <div id="mode-display" class="text-center mb-3 text-sm">
    <span>Mode: <span class="mode-indicator mode-live">LIVE</span></span>
  </div>

  <!-- Features Toggle -->
  <div class="bg-gray-800/50 p-4 rounded-lg mb-3">
    <h3 class="font-bold mb-2">Display Options</h3>
    <div class="space-y-2">
      <button id="toggle-labels" class="w-full py-2 px-3 rounded font-medium bg-indigo-700/80 hover:bg-indigo-600 transition on text-sm">Labels: ON</button>
      <button id="toggle-orbits" class="w-full py-2 px-3 rounded font-medium bg-violet-700/80 hover:bg-violet-600 transition on text-sm">Orbits: ON</button>
      <button id="toggle-lines" class="w-full py-2 px-3 rounded font-medium bg-amber-700/80 hover:bg-amber-600 transition on text-sm">Sight Lines: ON</button>
      <button id="toggle-zodiac" class="w-full py-2 px-3 rounded font-medium bg-teal-700/80 hover:bg-teal-600 transition on text-sm">Zodiac: ON</button>
      <button id="toggle-chart" class="w-full py-2 px-3 rounded font-medium bg-rose-700/80 hover:bg-rose-600 transition on text-sm">Chart: ON</button>
      <button id="toggle-aspects" class="w-full py-2 px-3 rounded font-medium bg-cyan-700/80 hover:bg-cyan-600 transition on text-sm">Aspects: ON</button>
    </div>
  </div>

  <!-- House System -->
  <div class="bg-gray-800/50 p-4 rounded-lg mb-3">
    <h3 class="font-bold mb-2">House System</h3>
    <select id="house-system" class="text-sm">
      <option value="placidus">Placidus</option>
      <option value="whole" selected>Whole Sign</option>
      <option value="equal">Equal House</option>
      <option value="koch">Koch</option>
    </select>
  </div>

  <!-- Animation Speed -->
  <div class="bg-gray-800/50 p-4 rounded-lg">
    <h3 class="font-bold mb-2">Animation Speed</h3>
    <div class="flex gap-2 flex-wrap">
      <button onclick="setSpeed(0)" class="speed-btn px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-xs">Pause</button>
      <button onclick="setSpeed(0.2)" class="speed-btn px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-xs">0.2Ã—</button>
      <button onclick="setSpeed(1)" class="speed-btn px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 on text-xs">1Ã—</button>
      <button onclick="setSpeed(10)" class="speed-btn px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-xs">10Ã—</button>
      <button onclick="setSpeed(50)" class="speed-btn px-3 py-2 rounded bg-gray-700 hover:bg-gray-600 text-xs">50Ã—</button>
    </div>
  </div>

  <button onclick="resetView()" class="w-full mt-4 py-2 px-4 rounded font-medium bg-gray-700 hover:bg-gray-600 text-sm">Reset View</button>
</div>

<div id="chart-overlay">
  <div id="chart-header">
    <h2 class="text-xl font-bold mb-2 text-center">
      Astrological Chart
      <div class="text-xs text-gray-400 font-normal mt-1" id="chart-date-display">Current Transits</div>
    </h2>
  </div>
  <div id="astro-chart">
    <div class="chart-circle chart-wheel"></div>
    <div class="chart-circle chart-inner"></div>
  </div>
  <div id="planet-positions" class="mt-4 text-xs space-y-1"></div>
  
  <!-- Aspects Display -->
  <div id="aspects-display" class="mt-4">
    <div class="font-bold text-sm mb-2">Major Aspects:</div>
    <div id="aspects-list" class="text-xs space-y-1"></div>
  </div>
</div>

<div id="viewer"></div>
<div id="tooltip" class="tooltip"></div>

<script>
// Astronomical constants
const J2000 = 2451545.0;
const DEG_TO_RAD = Math.PI / 180;
const RAD_TO_DEG = 180 / Math.PI;

// Planet orbital elements (J2000 epoch)
const planetData = [
  {name:"Sun",     symbol:"â˜‰", color:0xffee88, size:26, chartColor:"#ffdd66"},
  {name:"Mercury", symbol:"â˜¿", color:0xbbbbbb, size:7, chartColor:"#bbbbbb", 
   a:0.387098, e:0.205630, i:7.005, L:252.25, lp:77.46, ln:48.33, period:87.97},
  {name:"Venus",   symbol:"â™€", color:0xffccaa, size:10, chartColor:"#ffccaa",
   a:0.723332, e:0.006772, i:3.395, L:181.98, lp:131.56, ln:76.67, period:224.70},
  {name:"Earth",   symbol:"ðŸœ¨", color:0x4488ff, size:11, chartColor:"#4488ff",
   tex:"https://upload.wikimedia.org/wikipedia/commons/c/c3/Solarsystemscope_texture_2k_earth_daymap.jpg",
   a:1.000001, e:0.016709, i:0.000, L:100.47, lp:102.94, ln:0, period:365.25},
  {name:"Mars",    symbol:"â™‚", color:0xff5555, size:8.5, chartColor:"#ff5555",
   a:1.523688, e:0.093405, i:1.850, L:355.43, lp:336.06, ln:49.56, period:686.98},
  {name:"Jupiter", symbol:"â™ƒ", color:0xffaa33, size:18, chartColor:"#ffaa33",
   a:5.202887, e:0.048498, i:1.304, L:34.40, lp:14.75, ln:100.46, period:4332.59},
  {name:"Saturn",  symbol:"â™„", color:0xcccccc, size:15, chartColor:"#cccccc",
   a:9.536676, e:0.055546, i:2.488, L:50.08, lp:93.06, ln:113.66, period:10759.22},
  {name:"Uranus",  symbol:"â›¢", color:0x88ffff, size:12, chartColor:"#88ffff",
   a:19.189165, e:0.047318, i:0.773, L:314.05, lp:173.01, ln:74.01, period:30685.40},
  {name:"Neptune", symbol:"â™†", color:0x7777ff, size:12, chartColor:"#7777ff",
   a:30.069923, e:0.008678, i:1.770, L:304.35, lp:48.12, ln:131.78, period:60189.00}
];

const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
const signSymbols = ["â™ˆ","â™‰","â™Š","â™‹","â™Œ","â™","â™Ž","â™","â™","â™‘","â™’","â™“"];

// Aspect definitions
const aspects = [
  {name: "Conjunction", angle: 0, orb: 8, color: "#fbbf24", symbol: "â˜Œ"},
  {name: "Opposition", angle: 180, orb: 8, color: "#ef4444", symbol: "â˜"},
  {name: "Trine", angle: 120, orb: 8, color: "#10b981", symbol: "â–³"},
  {name: "Square", angle: 90, orb: 7, color: "#f97316", symbol: "â–¡"},
  {name: "Sextile", angle: 60, orb: 6, color: "#3b82f6", symbol: "âš¹"}
];

let scene, camera, renderer, labelRenderer, controls;
let planetMeshes = {}, sunMesh, moon, zodiacGroup, orbits = [], sightLines = [], starField;
let showLabels = true, showOrbits = true, showLines = true, showZodiac = true, showChart = true, showAspects = true;
let timeScale = 1;
let clock = new THREE.Clock();
let currentJD = dateToJulianDay(new Date());
let isNatalMode = false;
let natalData = null;
let houseSystem = 'whole';

init();
createScene();
createAstroChart();
animate();

function init() {
  scene = new THREE.Scene(); 
  scene.background = new THREE.Color(0x050508);
  
  camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(260, 320, 450);
  
  renderer = new THREE.WebGLRenderer({antialias:true}); 
  renderer.setSize(innerWidth, innerHeight); 
  renderer.setPixelRatio(devicePixelRatio);
  document.getElementById('viewer').appendChild(renderer.domElement);

  labelRenderer = new THREE.CSS2DRenderer(); 
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute'; 
  labelRenderer.domElement.style.top = '0'; 
  labelRenderer.domElement.style.pointerEvents = 'none';
  document.getElementById('viewer').appendChild(labelRenderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement); 
  controls.enableDamping = true; 
  controls.dampingFactor = 0.12;
  controls.minDistance = 80; 
  controls.maxDistance = 2200;

  scene.add(new THREE.AmbientLight(0x505050, 1.8));
  
  const sunLight = new THREE.PointLight(0xffffff, 4, 0);
  sunLight.name = "sunLight";
  scene.add(sunLight);

  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  scene.add(hemiLight);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); 
    labelRenderer.setSize(innerWidth, innerHeight);
  });
}

function createScene() {
  // Starfield
  const starsGeo = new THREE.BufferGeometry();
  const count = 8000;
  const pos = new Float32Array(count * 3);
  for (let i = 0; i < count * 3; i++) pos[i] = (Math.random() - 0.5) * 3200;
  starsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  starField = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xaaaaaa, size:1.6}));
  scene.add(starField);

  // Sun
  sunMesh = new THREE.Mesh(
    new THREE.SphereGeometry(26, 64, 64), 
    new THREE.MeshBasicMaterial({color:0xffee88})
  );
  sunMesh.name = "Sun";
  scene.add(sunMesh);

  const sunDiv = document.createElement('div');
  sunDiv.className = 'label';
  sunDiv.innerHTML = `â˜‰ <span style="font-size:0.82em">Sun</span>`;
  sunMesh.label = new THREE.CSS2DObject(sunDiv);
  scene.add(sunMesh.label);

  // Planets
  planetData.forEach(p => {
    if (p.name === "Sun") return;
    
    let mat;
    if (p.tex) {
      const tex = new THREE.TextureLoader().load(p.tex);
      tex.colorSpace = THREE.SRGBColorSpace;
      mat = new THREE.MeshPhongMaterial({
        map: tex, 
        emissive: 0x223344, 
        emissiveIntensity: 0.2,
        shininess: 20
      });
    } else {
      mat = new THREE.MeshPhongMaterial({
        color: p.color, 
        emissive: p.color, 
        emissiveIntensity: 0.8, 
        shininess: 10
      });
    }
    
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.size, 48, 48), mat);
    mesh.name = p.name;
    scene.add(mesh);

    const div = document.createElement('div');
    div.className = 'label';
    div.innerHTML = `${p.symbol} <span style="font-size:0.82em">${p.name}</span>`;
    const label = new THREE.CSS2DObject(div);
    scene.add(label);
    
    planetMeshes[p.name] = {mesh, label, data: p};
  });

  // Moon
  const moonTex = new THREE.TextureLoader().load("https://upload.wikimedia.org/wikipedia/commons/2/26/Solarsystemscope_texture_2k_moon.jpg");
  moon = new THREE.Mesh(
    new THREE.SphereGeometry(4.8, 32, 32), 
    new THREE.MeshPhongMaterial({
      map: moonTex,
      emissive: 0x333333,
      emissiveIntensity: 0.25,
      shininess: 8
    })
  );
  moon.name = "Moon";
  scene.add(moon);
  
  const moonDiv = document.createElement('div'); 
  moonDiv.className = 'label';
  moonDiv.innerHTML = `â˜½ Moon`;
  moon.label = new THREE.CSS2DObject(moonDiv); 
  scene.add(moon.label);

  // Create orbit paths
  planetData.forEach(p => {
    if (p.name === "Sun" || !p.a) return;
    const scale = 100;
    const curve = new THREE.EllipseCurve(0, 0, p.a * scale, p.a * scale * Math.sqrt(1 - p.e * p.e));
    const points = curve.getPoints(100);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    
    // Inclined orbit
    const inclinedLine = new THREE.Line(
      geometry.clone(),
      new THREE.LineBasicMaterial({color:0x334466, transparent:true, opacity:0.3})
    );
    inclinedLine.rotation.x = p.i * DEG_TO_RAD;
    inclinedLine.rotation.z = p.ln * DEG_TO_RAD;
    scene.add(inclinedLine);
    orbits.push(inclinedLine);
    
    // Flat orbit on ecliptic plane
    const flatLine = new THREE.Line(
      geometry.clone(),
      new THREE.LineBasicMaterial({color:0x445566, transparent:true, opacity:0.2})
    );
    scene.add(flatLine);
    orbits.push(flatLine);
  });

  // Zodiac wheel - on ecliptic plane (XZ plane in Three.js)
  zodiacGroup = new THREE.Group();
  const r = 580;
  
  const torus = new THREE.Mesh(
    new THREE.TorusGeometry(r, 12, 16, 128), 
    new THREE.MeshBasicMaterial({
      color:0x5577aa, 
      transparent:true, 
      opacity:0.55, 
      side:THREE.DoubleSide
    })
  );
  torus.rotation.x = Math.PI/2;
  zodiacGroup.add(torus);

  // Zodiac signs - Aries starts at vernal equinox (positive X axis)
  for (let i = 0; i < 12; i++) {
    const ang = i * (Math.PI * 2 / 12);
    
    zodiacGroup.add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0), 
        new THREE.Vector3(r*Math.cos(ang), 0, r*Math.sin(ang))
      ]), 
      new THREE.LineBasicMaterial({color:0x99aaff, transparent:true, opacity:0.45})
    ));

    const div = document.createElement('div'); 
    div.className = 'label'; 
    div.style.textAlign = 'center'; 
    div.style.lineHeight = '1.1';
    div.innerHTML = `<div style="font-size:15px;opacity:0.85">${signs[i]}</div><div style="font-size:38px">${signSymbols[i]}</div>`;
    const lbl = new THREE.CSS2DObject(div);
    const rr = r * 1.17;
    lbl.position.set(rr*Math.cos(ang), 0, rr*Math.sin(ang));
    zodiacGroup.add(lbl);
  }
  scene.add(zodiacGroup);
}

function createAstroChart() {
  const chartDiv = document.getElementById('astro-chart');
  
  // Create 12 house lines
  for (let i = 0; i < 12; i++) {
    const line = document.createElement('div');
    line.className = 'house-line';
    if (i === 0) line.classList.add('asc-line'); // Ascendant
    if (i === 9) line.classList.add('mc-line'); // Midheaven
    line.style.transform = `rotate(${i * 30}deg)`;
    line.id = `house-line-${i}`;
    chartDiv.appendChild(line);
  }
  
  // Add zodiac sign labels
  for (let i = 0; i < 12; i++) {
    const angle = (i * 30 - 90) * DEG_TO_RAD;
    const radius = 145;
    const x = 160 + radius * Math.cos(angle);
    const y = 160 + radius * Math.sin(angle);
    
    const signLabel = document.createElement('div');
    signLabel.className = 'sign-label';
    signLabel.textContent = signSymbols[i];
    signLabel.style.left = x + 'px';
    signLabel.style.top = y + 'px';
    chartDiv.appendChild(signLabel);
  }
  
  // Add house numbers
  for (let i = 0; i < 12; i++) {
    const angle = (i * 30 - 90 + 15) * DEG_TO_RAD;
    const radius = 80;
    const x = 160 + radius * Math.cos(angle);
    const y = 160 + radius * Math.sin(angle);
    
    const houseNum = document.createElement('div');
    houseNum.className = 'house-number';
    houseNum.textContent = i + 1;
    houseNum.style.left = x + 'px';
    houseNum.style.top = y + 'px';
    houseNum.id = `house-num-${i}`;
    chartDiv.appendChild(houseNum);
  }
}

function dateToJulianDay(date) {
  const a = Math.floor((14 - (date.getMonth() + 1)) / 12);
  const y = date.getFullYear() + 4800 - a;
  const m = (date.getMonth() + 1) + 12 * a - 3;
  
  let jd = date.getDate() + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
  
  const hour = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
  jd += (hour - 12) / 24;
  
  return jd;
}

function calculatePlanetPosition(planet, jd) {
  if (!planet.a) return null;
  
  const scale = 100;
  const T = (jd - J2000) / 36525;
  
  // Mean longitude
  let L = planet.L + (360 / planet.period) * (jd - J2000);
  L = L % 360;
  if (L < 0) L += 360;
  
  // Mean anomaly
  const M = (L - planet.lp) * DEG_TO_RAD;
  
  // Solve Kepler's equation
  let E = M;
  for (let i = 0; i < 10; i++) {
    E = M + planet.e * Math.sin(E);
  }
  
  // True anomaly
  const v = 2 * Math.atan2(
    Math.sqrt(1 + planet.e) * Math.sin(E / 2),
    Math.sqrt(1 - planet.e) * Math.cos(E / 2)
  );
  
  // Heliocentric distance
  const r = planet.a * (1 - planet.e * Math.cos(E));
  
  // Argument of perihelion from ascending node
  const w = (planet.lp - planet.ln) * DEG_TO_RAD;
  
  // Position in orbital plane
  const x_orb = r * Math.cos(v + w);
  const y_orb = r * Math.sin(v + w);
  
  // Convert to ecliptic coordinates (XZ plane, Y up)
  const omega = planet.ln * DEG_TO_RAD;
  const i = planet.i * DEG_TO_RAD;
  
  const x = (Math.cos(omega) * x_orb - Math.sin(omega) * y_orb * Math.cos(i)) * scale;
  const z = (Math.sin(omega) * x_orb + Math.cos(omega) * y_orb * Math.cos(i)) * scale;
  const y = y_orb * Math.sin(i) * scale;
  
  // Calculate ecliptic longitude for zodiac position
  const eclipticLon = Math.atan2(z, x) * RAD_TO_DEG;
  
  return { x, y, z, longitude: (eclipticLon + 360) % 360 };
}

function updatePlanetPositions(jd) {
  let earthPos = new THREE.Vector3(0, 0, 0);
  let positions = {};
  
  // Calculate all heliocentric positions
  planetData.forEach(p => {
    if (p.name === "Sun") return;
    
    const pos = calculatePlanetPosition(p, jd);
    if (pos) {
      positions[p.name] = pos;
      if (p.name === "Earth") {
        earthPos.set(pos.x, pos.y, pos.z);
      }
    }
  });
  
  // Update 3D positions (geocentric view - Earth at center)
  sunMesh.position.copy(earthPos).negate();
  
  Object.entries(positions).forEach(([name, pos]) => {
    if (planetMeshes[name]) {
      if (name === "Earth") {
        planetMeshes[name].mesh.position.set(0, 0, 0);
      } else {
        planetMeshes[name].mesh.position.set(
          pos.x - earthPos.x,
          pos.y - earthPos.y,
          pos.z - earthPos.z
        );
      }
    }
  });
  
  // Update moon
  const moonPhase = (jd - J2000) / 27.3 * 2 * Math.PI;
  const moonRadius = 32;
  moon.position.set(
    moonRadius * Math.cos(moonPhase),
    Math.sin(moonPhase) * 6,
    moonRadius * Math.sin(moonPhase)
  );
  
  // Calculate geocentric zodiac positions
  let chartPositions = {};
  
  // Sun as seen from Earth
  const sunRelative = new THREE.Vector3().copy(earthPos).negate();
  const sunZodiac = calculateZodiacFromPosition(sunRelative);
  chartPositions['Sun'] = {
    symbol: 'â˜‰',
    angle: sunZodiac.angle,
    sign: sunZodiac.sign,
    degree: sunZodiac.degree,
    color: '#ffdd66'
  };
  
  // Planets as seen from Earth
  Object.entries(positions).forEach(([name, pos]) => {
    if (name === "Earth") return;
    const relPos = new THREE.Vector3(pos.x - earthPos.x, pos.y - earthPos.y, pos.z - earthPos.z);
    const zodiac = calculateZodiacFromPosition(relPos);
    const planetInfo = planetData.find(p => p.name === name);
    chartPositions[name] = {
      symbol: planetInfo.symbol,
      angle: zodiac.angle,
      sign: zodiac.sign,
      degree: zodiac.degree,
      color: planetInfo.chartColor
    };
  });
  
  // Moon
  const moonZodiac = calculateZodiacFromPosition(moon.position);
  chartPositions['Moon'] = {
    symbol: 'â˜½',
    angle: moonZodiac.angle,
    sign: moonZodiac.sign,
    degree: moonZodiac.degree,
    color: '#cccccc'
  };
  
  return chartPositions;
}

function calculateZodiacFromPosition(vec3) {
  // Calculate angle in XZ plane (ecliptic)
  let angle = Math.atan2(vec3.z, vec3.x) * RAD_TO_DEG;
  if (angle < 0) angle += 360;
  
  const signIndex = Math.floor(angle / 30);
  const degreeInSign = angle % 30;
  
  return {
    angle: angle,
    sign: signs[signIndex],
    signSymbol: signSymbols[signIndex],
    degree: degreeInSign
  };
}

function calculateHouses(jd, lat, lon, ascendant) {
  const system = document.getElementById('house-system').value;
  const houses = [];
  
  if (system === 'whole') {
    // Whole sign houses - each house is one sign
    for (let i = 0; i < 12; i++) {
      houses.push((ascendant + i * 30) % 360);
    }
  } else if (system === 'equal') {
    // Equal houses - 30Â° each starting from ascendant
    for (let i = 0; i < 12; i++) {
      houses.push((ascendant + i * 30) % 360);
    }
  } else {
    // Placidus/Koch (simplified approximation)
    const mc = (ascendant + 90) % 360;
    houses[0] = ascendant;
    houses[9] = mc;
    
    for (let i = 1; i < 9; i++) {
      if (i === 3) houses[i] = (ascendant + 180) % 360; // IC
      else if (i === 6) houses[i] = (mc + 180) % 360; // Descendant
      else houses[i] = (ascendant + i * 30) % 360;
    }
    
    houses[10] = (mc + 30) % 360;
    houses[11] = (mc + 60) % 360;
  }
  
  return houses;
}

function calculateAspects(chartPositions) {
  const bodies = Object.keys(chartPositions);
  const foundAspects = [];
  
  for (let i = 0; i < bodies.length; i++) {
    for (let j = i + 1; j < bodies.length; j++) {
      const body1 = bodies[i];
      const body2 = bodies[j];
      const angle1 = chartPositions[body1].angle;
      const angle2 = chartPositions[body2].angle;
      
      let diff = Math.abs(angle1 - angle2);
      if (diff > 180) diff = 360 - diff;
      
      for (const aspect of aspects) {
        if (Math.abs(diff - aspect.angle) <= aspect.orb) {
          foundAspects.push({
            body1,
            body2,
            aspect: aspect.name,
            symbol: aspect.symbol,
            color: aspect.color,
            angle: diff,
            orb: Math.abs(diff - aspect.angle)
          });
        }
      }
    }
  }
  
  return foundAspects;
}

function updateAstroChart(chartPositions) {
  const chartDiv = document.getElementById('astro-chart');
  
  // Update house cusps
  if (natalData && natalData.ascendant !== undefined) {
    const houses = calculateHouses(currentJD, natalData.lat, natalData.lon, natalData.ascendant);
    houses.forEach((houseCusp, i) => {
      const line = document.getElementById(`house-line-${i}`);
      if (line) {
        line.style.transform = `rotate(${houseCusp - 90}deg)`;
      }
      
      const houseNum = document.getElementById(`house-num-${i}`);
      if (houseNum) {
        const angle = (houseCusp - 90 + 15) * DEG_TO_RAD;
        const radius = 80;
        const x = 160 + radius * Math.cos(angle);
        const y = 160 + radius * Math.sin(angle);
        houseNum.style.left = x + 'px';
        houseNum.style.top = y + 'px';
      }
    });
  }
  
  // Remove old elements
  chartDiv.querySelectorAll('.planet-marker').forEach(el => el.remove());
  chartDiv.querySelectorAll('.aspect-line').forEach(el => el.remove());
  
  // Calculate aspects
  const foundAspects = calculateAspects(chartPositions);
  
  // Draw aspect lines
  if (showAspects) {
    foundAspects.forEach(asp => {
      const pos1 = chartPositions[asp.body1];
      const pos2 = chartPositions[asp.body2];
      
      const displayAngle1 = natalData ? pos1.angle - natalData.ascendant : pos1.angle;
      const displayAngle2 = natalData ? pos2.angle - natalData.ascendant : pos2.angle;
      
      const angle1 = (displayAngle1 - 90) * DEG_TO_RAD;
      const angle2 = (displayAngle2 - 90) * DEG_TO_RAD;
      const radius = 115;
      
      const x1 = radius * Math.cos(angle1);
      const y1 = radius * Math.sin(angle1);
      const x2 = radius * Math.cos(angle2);
      const y2 = radius * Math.sin(angle2);
      
      const length = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
      const lineAngle = Math.atan2(y2-y1, x2-x1) * RAD_TO_DEG;
      
      const line = document.createElement('div');
      line.className = `aspect-line aspect-${asp.aspect.toLowerCase()}`;
      line.style.width = length + 'px';
      line.style.transform = `translate(${x1}px, ${y1}px) rotate(${lineAngle}deg)`;
      line.style.background = asp.color;
      chartDiv.appendChild(line);
    });
  }
  
  // Add planet markers
  Object.entries(chartPositions).forEach(([name, data]) => {
    const displayAngle = natalData ? data.angle - natalData.ascendant : data.angle;
    const angle = (displayAngle - 90) * DEG_TO_RAD;
    const radius = 115;
    const x = 160 + radius * Math.cos(angle);
    const y = 160 + radius * Math.sin(angle);
    
    const marker = document.createElement('div');
    marker.className = 'planet-marker';
    marker.style.left = x + 'px';
    marker.style.top = y + 'px';
    marker.style.borderColor = data.color;
    marker.innerHTML = data.symbol;
    marker.dataset.planet = name;
    
    marker.addEventListener('mouseenter', (e) => {
      const tooltip = document.getElementById('tooltip');
      tooltip.innerHTML = `<strong>${data.symbol} ${name}</strong><br>${data.sign} ${data.degree.toFixed(2)}Â°`;
      tooltip.style.display = 'block';
    });
    
    marker.addEventListener('mousemove', (e) => {
      const tooltip = document.getElementById('tooltip');
      tooltip.style.left = (e.clientX + 15) + 'px';
      tooltip.style.top = (e.clientY + 15) + 'px';
    });
    
    marker.addEventListener('mouseleave', () => {
      document.getElementById('tooltip').style.display = 'none';
    });
    
    const degreeLabel = document.createElement('div');
    degreeLabel.className = 'planet-degree';
    degreeLabel.textContent = `${data.sign} ${data.degree.toFixed(1)}Â°`;
    marker.appendChild(degreeLabel);
    
    chartDiv.appendChild(marker);
  });
  
  // Update position list
  const posDiv = document.getElementById('planet-positions');
  let html = '<div class="font-bold mb-2">Planetary Positions:</div>';
  Object.entries(chartPositions).forEach(([name, data]) => {
    html += `<div style="color:${data.color}">
      ${data.symbol} ${name}: ${data.sign} ${data.degree.toFixed(1)}Â°
    </div>`;
  });
  posDiv.innerHTML = html;
  
  // Update aspects list
  const aspectsDiv = document.getElementById('aspects-list');
  let aspectsHtml = '';
  foundAspects.forEach(asp => {
    aspectsHtml += `<div class="aspect-item" style="border-left: 3px solid ${asp.color}">
      ${chartPositions[asp.body1].symbol} ${asp.symbol} ${chartPositions[asp.body2].symbol} - ${asp.aspect} (${asp.orb.toFixed(1)}Â° orb)
    </div>`;
  });
  aspectsDiv.innerHTML = aspectsHtml || '<div class="text-gray-500">No major aspects</div>';
}

function animate() {
  requestAnimationFrame(animate);
  
  if (!isNatalMode && timeScale > 0) {
    currentJD += clock.getDelta() * timeScale / 86400;
  } else {
    clock.getDelta();
  }
  
  const chartPositions = updatePlanetPositions(currentJD);
  
  if (showChart) {
    updateAstroChart(chartPositions);
  }
  
  // Update labels
  sunMesh.label.position.copy(sunMesh.position);
  sunMesh.label.position.y += 46;
  sunMesh.label.visible = showLabels;
  
  Object.values(planetMeshes).forEach(p => {
    p.label.position.copy(p.mesh.position);
    p.label.position.y += p.data.size + 20;
    p.label.visible = showLabels;
    p.label.element.style.opacity = THREE.MathUtils.clamp(
      1.6 - camera.position.distanceTo(p.mesh.position)/1100, 
      0.15, 
      1
    );
  });
  
  moon.label.position.copy(moon.position);
  moon.label.position.y += 14;
  moon.label.visible = showLabels;
  
  // Only rotate zodiac in live mode
  if (!isNatalMode) {
    zodiacGroup.rotation.y += 0.00015;
  }
  
  // Update sight lines
  if (showLines) {
    sightLines.forEach(l => scene.remove(l)); 
    sightLines = [];
    
    const observationPoint = new THREE.Vector3(0, 0, 0);
    
    [sunMesh, ...Object.values(planetMeshes).map(p => p.mesh), moon].forEach(obj => {
      if (obj.name === "Earth") return;
      
      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          observationPoint,
          obj.position
        ]),
        new THREE.LineBasicMaterial({color:0xffdd88, transparent:true, opacity:0.4})
      );
      scene.add(line);
      sightLines.push(line);
    });
  }
  
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}

// Preset data loader
function loadPreset(preset) {
  const now = new Date();
  
  if (preset === 'current') {
    document.getElementById('birth-date').value = now.toISOString().split('T')[0];
    document.getElementById('birth-time').value = now.toTimeString().slice(0,5);
    document.getElementById('birth-location').value = 'Current Time';
    document.getElementById('birth-lat').value = '0';
    document.getElementById('birth-lon').value = '0';
  } else if (preset === 'example1') {
    document.getElementById('birth-date').value = '1990-06-21';
    document.getElementById('birth-time').value = '14:30';
    document.getElementById('birth-location').value = 'London, UK';
    document.getElementById('birth-lat').value = '51.5074';
    document.getElementById('birth-lon').value = '-0.1278';
  } else if (preset === 'example2') {
    document.getElementById('birth-date').value = '1985-12-25';
    document.getElementById('birth-time').value = '08:15';
    document.getElementById('birth-location').value = 'New York, USA';
    document.getElementById('birth-lat').value = '40.7128';
    document.getElementById('birth-lon').value = '-74.0060';
  }
}

// Calculate Natal Chart
document.getElementById('calculate-natal').addEventListener('click', function() {
  const dateStr = document.getElementById('birth-date').value;
  const timeStr = document.getElementById('birth-time').value;
  const lat = parseFloat(document.getElementById('birth-lat').value) || 0;
  const lon = parseFloat(document.getElementById('birth-lon').value) || 0;
  const location = document.getElementById('birth-location').value || 'Unknown';
  
  if (!dateStr || !timeStr) {
    alert('Please enter birth date and time');
    return;
  }
  
  const dateTime = new Date(dateStr + 'T' + timeStr);
  currentJD = dateToJulianDay(dateTime);
  
  // Calculate Local Sidereal Time (simplified)
  const ut = dateTime.getUTCHours() + dateTime.getUTCMinutes() / 60;
  const jd0 = Math.floor(currentJD - 0.5) + 0.5;
  const T = (jd0 - J2000) / 36525;
  const theta0 = 280.46061837 + 360.98564736629 * (jd0 - J2000) + T * T * (0.000387933 - T / 38710000);
  const lst = (theta0 + lon + ut * 15) % 360;
  
  // Calculate ascendant (simplified)
  const ascendant = (lst + 90) % 360;
  
  natalData = {
    date: dateTime,
    lat: lat,
    lon: lon,
    location: location,
    ascendant: ascendant
  };
  
  isNatalMode = true;
  timeScale = 0;
  
  document.getElementById('mode-display').innerHTML = 
    `Mode: <span class="mode-indicator mode-natal">NATAL CHART</span>`;
  
  document.getElementById('chart-date-display').textContent = 
    `${location} - ${dateTime.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })}`;
  
  setSpeed(0);
});

// Show Current Transits
document.getElementById('show-now').addEventListener('click', function() {
  currentJD = dateToJulianDay(new Date());
  isNatalMode = false;
  natalData = null;
  timeScale = 1;
  
  document.getElementById('mode-display').innerHTML = 
    `Mode: <span class="mode-indicator mode-live">LIVE</span>`;
  
  document.getElementById('chart-date-display').textContent = 'Current Planetary Positions';
  
  for (let i = 0; i < 12; i++) {
    const line = document.getElementById(`house-line-${i}`);
    if (line) {
      line.style.transform = `rotate(${i * 30}deg)`;
    }
  }
});

// House system change
document.getElementById('house-system').addEventListener('change', function() {
  houseSystem = this.value;
  if (natalData) {
    const chartPositions = updatePlanetPositions(currentJD);
    updateAstroChart(chartPositions);
  }
});

// Toggle Controls
document.getElementById('toggle-labels').addEventListener('click', function() {
  showLabels = !showLabels;
  this.classList.toggle('on', showLabels);
  this.textContent = `Labels: ${showLabels ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-orbits').addEventListener('click', function() {
  showOrbits = !showOrbits;
  orbits.forEach(o => o.visible = showOrbits);
  this.classList.toggle('on', showOrbits);
  this.textContent = `Orbits: ${showOrbits ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-lines').addEventListener('click', function() {
  showLines = !showLines;
  if (!showLines) {
    sightLines.forEach(l => scene.remove(l));
    sightLines = [];
  }
  this.classList.toggle('on', showLines);
  this.textContent = `Sight Lines: ${showLines ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-zodiac').addEventListener('click', function() {
  showZodiac = !showZodiac;
  zodiacGroup.visible = showZodiac;
  this.classList.toggle('on', showZodiac);
  this.textContent = `Zodiac: ${showZodiac ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-chart').addEventListener('click', function() {
  showChart = !showChart;
  document.getElementById('chart-overlay').style.display = showChart ? 'block' : 'none';
  this.classList.toggle('on', showChart);
  this.textContent = `Chart: ${showChart ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-aspects').addEventListener('click', function() {
  showAspects = !showAspects;
  this.classList.toggle('on', showAspects);
  this.textContent = `Aspects: ${showAspects ? 'ON' : 'OFF'}`;
  const chartPositions = updatePlanetPositions(currentJD);
  updateAstroChart(chartPositions);
});

function setSpeed(v) {
  timeScale = v;
  document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('on'));
  event.target.classList.add('on');
}

function resetView() {
  camera.position.set(260, 320, 450);
  controls.target.set(0, 0, 0);
  controls.update();
}

// Make chart overlay draggable
(function() {
  const chartOverlay = document.getElementById('chart-overlay');
  const header = document.getElementById('chart-header');
  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;
  let xOffset = 0;
  let yOffset = 0;

  header.addEventListener('mousedown', dragStart);
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', dragEnd);

  function dragStart(e) {
    initialX = e.clientX - xOffset;
    initialY = e.clientY - yOffset;

    if (e.target === header || header.contains(e.target)) {
      isDragging = true;
    }
  }

  function drag(e) {
    if (isDragging) {
      e.preventDefault();
      
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;

      xOffset = currentX;
      yOffset = currentY;

      setTranslate(currentX, currentY, chartOverlay);
    }
  }

  function dragEnd(e) {
    initialX = currentX;
    initialY = currentY;
    isDragging = false;
  }

  function setTranslate(xPos, yPos, el) {
    el.style.transform = `translate(${xPos}px, ${yPos}px)`;
  }
})();

</script>
</body>
</html>
