<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Esoteric Chart â€¢ True Geocentric Mode</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS2DRenderer.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { margin:0; overflow:hidden; background:#0a0a0f; font-family:system-ui,sans-serif; }
  #viewer { position:absolute; inset:0; }
  #sidebar { position:absolute; left:0; top:0; bottom:0; width:360px; background:rgba(15,15,30,0.94); backdrop-filter:blur(12px); border-right:1px solid #333; overflow-y:auto; z-index:10; padding:24px; }
  #chart-overlay { position:absolute; right:20px; top:20px; width:340px; background:rgba(15,15,30,0.96); backdrop-filter:blur(12px); border:1px solid #444; border-radius:12px; padding:20px; z-index:10; }
  .label { pointer-events:none; font-weight:bold; text-shadow:0 0 8px #000, 0 0 12px #000; white-space:nowrap; font-size:21px; color:#f0f0ff; }
  button.on { background-color:#6366f1 !important; color:white; }
  button.off { background-color:#4b5563 !important; color:white; }
  #toggle-view { transition: all 0.3s; }
  #toggle-view.heliocentric { background: linear-gradient(to right, #6366f1, #a855f7); }
  #toggle-view.geocentric   { background: linear-gradient(to right, #10b981, #34d399); }
  
  #astro-chart { position: relative; width: 300px; height: 300px; margin: 0 auto; }
  .chart-circle { position: absolute; border-radius: 50%; border: 2px solid #5577aa; }
  .chart-wheel { width: 300px; height: 300px; top: 0; left: 0; }
  .chart-inner { width: 200px; height: 200px; top: 50px; left: 50px; border-color: #667799; }
  .house-line { position: absolute; width: 2px; height: 150px; background: #667799; top: 0; left: 149px; transform-origin: 1px 150px; opacity: 0.5; }
  .planet-marker { position: absolute; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; background: rgba(0,0,0,0.7); border: 2px solid; transform: translate(-50%, -50%); }
  .planet-degree { position: absolute; font-size: 10px; color: #aaa; margin-top: 32px; white-space: nowrap; }
  .sign-label { position: absolute; font-size: 11px; color: #99aacc; font-weight: bold; transform: translate(-50%, -50%); }
</style>
</head>
<body class="text-gray-200">

<div id="sidebar">
  <h1 class="text-3xl font-bold mb-1 text-center">Esoteric 3D</h1>
  <p class="text-gray-400 text-center mb-4">Astronomically Accurate Astrology</p>

  <button id="toggle-view" class="w-full py-4 px-4 rounded font-medium text-lg font-bold heliocentric">
    Switch to Geocentric
  </button>

  <div class="space-y-3 mt-6">
    <button id="toggle-labels" class="w-full py-3 px-4 rounded font-medium bg-indigo-700/80 hover:bg-indigo-600 transition on">Labels: ON</button>
    <button id="toggle-orbits" class="w-full py-3 px-4 rounded font-medium bg-violet-700/80 hover:bg-violet-600 transition on">Orbits: ON</button>
    <button id="toggle-lines" class="w-full py-3 px-4 rounded font-medium bg-amber-700/80 hover:bg-amber-600 transition on">Sight Lines: ON</button>
    <button id="toggle-zodiac" class="w-full py-3 px-4 rounded font-medium bg-teal-700/80 hover:bg-teal-600 transition on">Zodiac: ON</button>
    <button id="toggle-stars" class="w-full py-3 px-4 rounded font-medium bg-purple-700/80 hover:bg-purple-600 transition on">Stars: ON</button>
    <button id="toggle-chart" class="w-full py-3 px-4 rounded font-medium bg-rose-700/80 hover:bg-rose-600 transition on">Chart: ON</button>
  </div>

  <div class="mt-8">
    <label class="block text-gray-400 text-sm mb-2">Speed (Earth days/sec)</label>
    <div class="flex gap-2 flex-wrap">
      <button onclick="setSpeed(0.2)" class="speed-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600">0.2Ã—</button>
      <button onclick="setSpeed(1)" class="speed-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600 on">1Ã—</button>
      <button onclick="setSpeed(500)" class="speed-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600">500Ã—</button>
      <button onclick="setSpeed(5000)" class="speed-btn px-4 py-2 rounded bg-gray-700 hover:bg-gray-600">5kÃ—</button>
    </div>
  </div>

  <button id="pause-btn" onclick="togglePause()" class="w-full mt-6 py-3 px-4 rounded font-medium bg-emerald-700 hover:bg-emerald-600">Pause</button>
  <button onclick="resetView()" class="w-full mt-3 py-3 px-4 rounded font-medium bg-gray-700 hover:bg-gray-600">Reset View</button>
</div>

<div id="chart-overlay">
  <h2 class="text-xl font-bold mb-4 text-center">Live Astrological Chart</h2>
  <div id="astro-chart">
    <div class="chart-circle chart-wheel"></div>
    <div class="chart-circle chart-inner"></div>
    <!-- House lines will be added dynamically -->
  </div>
  <div id="planet-positions" class="mt-4 text-xs space-y-1"></div>
</div>

<div id="viewer"></div>

<script>
// Real inclinations (degrees) relative to ecliptic
const inclinations = { Mercury:7.005, Venus:3.395, Earth:0, Mars:1.850, Jupiter:1.304, Saturn:2.488, Uranus:0.773, Neptune:1.770 };

const planetData = [
  {name:"Sun",     symbol:"â˜‰", radius:0,    period:0,     size:26,  color:0xffee88, initial:0, chartColor:"#ffdd66"},
  {name:"Mercury", symbol:"â˜¿", radius:65,   period:88,    size:7,   color:0xbbbbbb, initial:4.85, chartColor:"#bbbbbb"},
  {name:"Venus",   symbol:"â™€", radius:98,   period:225,   size:10,  color:0xffccaa, initial:5.35, chartColor:"#ffccaa"},
  {name:"Earth",   symbol:"ðŸœ¨", radius:135,  period:365.25,size:11,  tex:"https://upload.wikimedia.org/wikipedia/commons/c/c3/Solarsystemscope_texture_2k_earth_daymap.jpg", initial:0.35, chartColor:"#4488ff"},
  {name:"Mars",    symbol:"â™‚", radius:175,  period:687,   size:8.5, color:0xff5555, initial:0.95, chartColor:"#ff5555"},
  {name:"Jupiter", symbol:"â™ƒ", radius:260,  period:4333,  size:18,  color:0xffaa33, initial:1.65, chartColor:"#ffaa33"},
  {name:"Saturn",  symbol:"â™„", radius:320,  period:10759, size:15,  color:0xeeeeee, initial:3.45, chartColor:"#cccccc"},
  {name:"Uranus",  symbol:"â›¢", radius:380,  period:30687, size:12,  color:0x88ffff, initial:5.10, chartColor:"#88ffff"},
  {name:"Neptune", symbol:"â™†", radius:430,  period:60190, size:12,  color:0x7777ff, initial:5.75, chartColor:"#7777ff"}
];

const signs = ["â™ˆ Aries","â™‰ Taurus","â™Š Gemini","â™‹ Cancer","â™Œ Leo","â™ Virgo","â™Ž Libra","â™ Scorpio","â™ Sagittarius","â™‘ Capricorn","â™’ Aquarius","â™“ Pisces"];
const signSymbols = ["â™ˆ","â™‰","â™Š","â™‹","â™Œ","â™","â™Ž","â™","â™","â™‘","â™’","â™“"];

let scene, camera, renderer, labelRenderer, controls;
let planets = [], sunMesh, moon, zodiacGroup, orbits = [], sightLines = [], starField;
let isGeocentric = false;
let showLabels = true, showOrbits = true, showLines = true, showZodiac = true, showStars = true, showChart = true;
let isPaused = false;
let timeScale = 1;
let clock = new THREE.Clock();
let animationTime = 0;

init();
createScene();
createAstroChart();
animate();

function init() {
  scene = new THREE.Scene(); 
  scene.background = new THREE.Color(0x050508);
  
  camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(260, 320, 450);
  
  renderer = new THREE.WebGLRenderer({antialias:true}); 
  renderer.setSize(innerWidth, innerHeight); 
  renderer.setPixelRatio(devicePixelRatio);
  document.getElementById('viewer').appendChild(renderer.domElement);

  labelRenderer = new THREE.CSS2DRenderer(); 
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute'; 
  labelRenderer.domElement.style.top = '0'; 
  labelRenderer.domElement.style.pointerEvents = 'none';
  document.getElementById('viewer').appendChild(labelRenderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement); 
  controls.enableDamping = true; 
  controls.dampingFactor = 0.12;
  controls.minDistance = 80; 
  controls.maxDistance = 2200;

  // Better lighting for textures
  scene.add(new THREE.AmbientLight(0x404040, 1.5)); // Increased ambient light
  
  const sunLight = new THREE.PointLight(0xffffff, 3.5, 0);
  sunLight.name = "sunLight";
  scene.add(sunLight);

  // Add hemisphere light for better visibility
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  scene.add(hemiLight);

  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight); 
    labelRenderer.setSize(innerWidth, innerHeight);
  });
}

function createScene() {
  // Starfield
  const starsGeo = new THREE.BufferGeometry();
  const count = 8000;
  const pos = new Float32Array(count * 3);
  for (let i = 0; i < count * 3; i++) pos[i] = (Math.random() - 0.5) * 3200;
  starsGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  starField = new THREE.Points(starsGeo, new THREE.PointsMaterial({color:0xaaaaaa, size:1.6}));
  scene.add(starField);

  // Sun
  sunMesh = new THREE.Mesh(
    new THREE.SphereGeometry(26, 64, 64), 
    new THREE.MeshBasicMaterial({color:0xffee88})
  );
  sunMesh.name = "Sun";
  scene.add(sunMesh);

  const sunDiv = document.createElement('div');
  sunDiv.className = 'label';
  sunDiv.innerHTML = `â˜‰ <span style="font-size:0.82em">Sun</span>`;
  sunMesh.label = new THREE.CSS2DObject(sunDiv);
  scene.add(sunMesh.label);

  // Planets
  planets = [];
  planetData.forEach(p => {
    if (p.radius === 0) return; // Skip Sun in planet array
    
    let mat;
    if (p.tex) {
      const tex = new THREE.TextureLoader().load(p.tex);
      tex.colorSpace = THREE.SRGBColorSpace;
      // Better material for Earth with emissive to make it visible
      mat = new THREE.MeshPhongMaterial({
        map: tex, 
        emissive: 0x222233, 
        emissiveIntensity: 0.15,
        shininess: 15
      });
    } else {
      mat = new THREE.MeshPhongMaterial({
        color: p.color, 
        emissive: p.color, 
        emissiveIntensity: 0.8, 
        shininess: 10
      });
    }
    
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.size, 48, 48), mat);
    mesh.name = p.name;
    scene.add(mesh);

    const div = document.createElement('div');
    div.className = 'label';
    div.innerHTML = `${p.symbol} <span style="font-size:0.82em">${p.name}</span>`;
    const label = new THREE.CSS2DObject(div);
    scene.add(label);
    
    planets.push({mesh, label, data: p});
  });

  // Moon with better visibility
  const moonTex = new THREE.TextureLoader().load("https://upload.wikimedia.org/wikipedia/commons/2/26/Solarsystemscope_texture_2k_moon.jpg");
  moon = new THREE.Mesh(
    new THREE.SphereGeometry(4.8, 32, 32), 
    new THREE.MeshPhongMaterial({
      map: moonTex,
      emissive: 0x222222,
      emissiveIntensity: 0.2,
      shininess: 5
    })
  );
  moon.name = "Moon";
  scene.add(moon);
  
  const moonDiv = document.createElement('div'); 
  moonDiv.className = 'label';
  moonDiv.innerHTML = `â˜½ Moon`;
  moon.label = new THREE.CSS2DObject(moonDiv); 
  scene.add(moon.label);

  // Orbits - both inclined and flat
  planetData.forEach(p => {
    if (p.radius === 0) return;
    const curve = new THREE.EllipseCurve(0, 0, p.radius, p.radius);
    const points = curve.getPoints(100);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    
    // Inclined orbit (actual)
    const inclinedLine = new THREE.Line(
      geometry.clone(),
      new THREE.LineBasicMaterial({color:0x334466, transparent:true, opacity:0.3})
    );
    const inc = (inclinations[p.name] || 0) * Math.PI/180;
    inclinedLine.rotation.x = inc;
    inclinedLine.name = `${p.name}OrbitInclined`;
    scene.add(inclinedLine);
    orbits.push(inclinedLine);
    
    // Flat orbit on XZ plane (ecliptic projection)
    const flatLine = new THREE.Line(
      geometry.clone(),
      new THREE.LineBasicMaterial({color:0x445566, transparent:true, opacity:0.2})
    );
    flatLine.rotation.x = Math.PI / 2; // Flat on XZ plane
    flatLine.name = `${p.name}OrbitFlat`;
    scene.add(flatLine);
    orbits.push(flatLine);
  });

  // Zodiac wheel - aligned with ecliptic plane (Earth's orbit)
  zodiacGroup = new THREE.Group();
  const r = 580;
  
  const torus = new THREE.Mesh(
    new THREE.TorusGeometry(r, 12, 16, 128), 
    new THREE.MeshBasicMaterial({
      color:0x5577aa, 
      transparent:true, 
      opacity:0.55, 
      side:THREE.DoubleSide
    })
  );
  torus.rotation.x = Math.PI/2;
  zodiacGroup.add(torus);

  // Zodiac starts at vernal equinox (Aries at 0Â°)
  for (let i = 0; i < 12; i++) {
    const ang = i * (Math.PI*2/12); // Start at 0 for Aries
    
    zodiacGroup.add(new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 8, 0), 
        new THREE.Vector3(r*1.05*Math.cos(ang), 8, r*1.05*Math.sin(ang))
      ]), 
      new THREE.LineBasicMaterial({color:0x99aaff, transparent:true, opacity:0.45})
    ));

    const div = document.createElement('div'); 
    div.className = 'label'; 
    div.style.textAlign = 'center'; 
    div.style.lineHeight = '1.1';
    div.innerHTML = `<div style="font-size:15px;opacity:0.85">${signs[i].split(' ')[1]}</div><div style="font-size:38px">${signs[i].split(' ')[0]}</div>`;
    const lbl = new THREE.CSS2DObject(div);
    const rr = r * 1.17;
    lbl.position.set(rr*Math.cos(ang), 40, rr*Math.sin(ang));
    zodiacGroup.add(lbl);
  }
  scene.add(zodiacGroup);
}

function createAstroChart() {
  const chartDiv = document.getElementById('astro-chart');
  
  // Create 12 house lines
  for (let i = 0; i < 12; i++) {
    const line = document.createElement('div');
    line.className = 'house-line';
    line.style.transform = `rotate(${i * 30}deg)`;
    chartDiv.appendChild(line);
  }
  
  // Add zodiac sign labels around the wheel
  for (let i = 0; i < 12; i++) {
    const angle = (i * 30 - 90) * Math.PI / 180; // Start at Aries (top)
    const radius = 135;
    const x = 150 + radius * Math.cos(angle);
    const y = 150 + radius * Math.sin(angle);
    
    const signLabel = document.createElement('div');
    signLabel.className = 'sign-label';
    signLabel.textContent = signSymbols[i];
    signLabel.style.left = x + 'px';
    signLabel.style.top = y + 'px';
    chartDiv.appendChild(signLabel);
  }
}

function updateAstroChart(planetPositions) {
  const chartDiv = document.getElementById('astro-chart');
  
  // Remove old planet markers
  chartDiv.querySelectorAll('.planet-marker').forEach(el => el.remove());
  
  // Add planet markers
  Object.entries(planetPositions).forEach(([name, data]) => {
    const angle = (data.angle - 90) * Math.PI / 180; // Convert to radians, adjust for top = 0Â°
    const radius = 115; // Position on chart
    const x = 150 + radius * Math.cos(angle);
    const y = 150 + radius * Math.sin(angle);
    
    const marker = document.createElement('div');
    marker.className = 'planet-marker';
    marker.style.left = x + 'px';
    marker.style.top = y + 'px';
    marker.style.borderColor = data.color;
    marker.innerHTML = data.symbol;
    
    const degreeLabel = document.createElement('div');
    degreeLabel.className = 'planet-degree';
    degreeLabel.textContent = `${data.sign} ${data.degree.toFixed(1)}Â°`;
    marker.appendChild(degreeLabel);
    
    chartDiv.appendChild(marker);
  });
  
  // Update position list
  const posDiv = document.getElementById('planet-positions');
  let html = '<div class="font-bold mb-2 text-sm">Planetary Positions:</div>';
  Object.entries(planetPositions).forEach(([name, data]) => {
    html += `<div style="color:${data.color}">
      ${data.symbol} ${name}: ${data.sign} ${data.degree.toFixed(1)}Â°
    </div>`;
  });
  posDiv.innerHTML = html;
}

function calculateZodiacPosition(x, z) {
  // Calculate angle from position (0Â° = Aries = positive X axis)
  let angle = Math.atan2(z, x) * 180 / Math.PI;
  if (angle < 0) angle += 360;
  
  // Determine sign (each sign is 30Â°)
  const signIndex = Math.floor(angle / 30);
  const degreeInSign = angle % 30;
  
  return {
    angle: angle,
    sign: signs[signIndex].split(' ')[1],
    signSymbol: signSymbols[signIndex],
    degree: degreeInSign,
    fullSign: signs[signIndex]
  };
}

function animate() {
  requestAnimationFrame(animate);
  
  if (!isPaused) {
    animationTime += clock.getDelta() * timeScale;
  } else {
    clock.getDelta(); // Keep clock running to avoid jumps
  }
  
  const days = animationTime;

  // Calculate heliocentric positions first
  let earthPos = new THREE.Vector3(0, 0, 0);
  let heliocentricPositions = {};
  
  planets.forEach(p => {
    if (!p.data.period) return;
    const ang = p.data.initial + 2 * Math.PI * days / p.data.period;
    const inc = (inclinations[p.data.name] || 0) * Math.PI / 180;

    let x = p.data.radius * Math.cos(ang);
    let z = p.data.radius * Math.sin(ang) * Math.cos(inc);
    let y = p.data.radius * Math.sin(ang) * Math.sin(inc);

    heliocentricPositions[p.data.name] = new THREE.Vector3(x, y, z);
    
    if (p.data.name === "Earth") {
      earthPos.copy(heliocentricPositions.Earth);
    }
  });

  // Store positions for chart calculation
  let chartPositions = {};

  // Apply coordinate system transformation
  if (isGeocentric) {
    // In geocentric view, Earth is at center (0,0,0)
    // Sun and all planets move relative to Earth
    sunMesh.position.copy(earthPos).negate();
    
    // Calculate Sun's zodiac position
    const sunZodiac = calculateZodiacPosition(sunMesh.position.x, sunMesh.position.z);
    chartPositions['Sun'] = {
      symbol: 'â˜‰',
      angle: sunZodiac.angle,
      sign: sunZodiac.sign,
      degree: sunZodiac.degree,
      color: '#ffdd66'
    };
    
    planets.forEach(p => {
      if (p.data.name === "Earth") {
        p.mesh.position.set(0, 0, 0);
      } else {
        p.mesh.position.copy(heliocentricPositions[p.data.name]).sub(earthPos);
        
        // Calculate zodiac position
        const zodiac = calculateZodiacPosition(p.mesh.position.x, p.mesh.position.z);
        chartPositions[p.data.name] = {
          symbol: p.data.symbol,
          angle: zodiac.angle,
          sign: zodiac.sign,
          degree: zodiac.degree,
          color: p.data.chartColor
        };
      }
    });
    
    // Update light position to follow Sun in geocentric view
    const sunLight = scene.getObjectByName("sunLight");
    if (sunLight) {
      sunLight.position.copy(sunMesh.position);
    }
  } else {
    // Heliocentric view - Sun at center
    sunMesh.position.set(0, 0, 0);
    
    planets.forEach(p => {
      if (heliocentricPositions[p.data.name]) {
        p.mesh.position.copy(heliocentricPositions[p.data.name]);
        
        // Calculate zodiac position from Earth's perspective
        const relativePos = new THREE.Vector3()
          .copy(p.mesh.position)
          .sub(earthPos);
        
        const zodiac = calculateZodiacPosition(relativePos.x, relativePos.z);
        chartPositions[p.data.name] = {
          symbol: p.data.symbol,
          angle: zodiac.angle,
          sign: zodiac.sign,
          degree: zodiac.degree,
          color: p.data.chartColor
        };
      }
    });
    
    // Sun as seen from Earth
    const sunRelative = new THREE.Vector3().copy(earthPos).negate();
    const sunZodiac = calculateZodiacPosition(sunRelative.x, sunRelative.z);
    chartPositions['Sun'] = {
      symbol: 'â˜‰',
      angle: sunZodiac.angle,
      sign: sunZodiac.sign,
      degree: sunZodiac.degree,
      color: '#ffdd66'
    };
    
    // Light stays at origin
    const sunLight = scene.getObjectByName("sunLight");
    if (sunLight) {
      sunLight.position.set(0, 0, 0);
    }
  }

  // Update astrological chart
  if (showChart) {
    updateAstroChart(chartPositions);
  }

  // Update labels
  sunMesh.label.position.copy(sunMesh.position);
  sunMesh.label.position.y += 46;
  
  planets.forEach(p => {
    p.label.position.copy(p.mesh.position);
    p.label.position.y += p.data.size + 20;
    p.label.element.style.opacity = THREE.MathUtils.clamp(
      1.6 - camera.position.distanceTo(p.mesh.position)/1100, 
      0.15, 
      1
    );
  });

  // Moon orbit around Earth
  const moonAng = days / 27.3 * 2 * Math.PI * 9;
  const mr = 32;
  const earthMesh = planets.find(p => p.data.name === "Earth").mesh;
  
  moon.position.x = earthMesh.position.x + mr * Math.cos(moonAng);
  moon.position.z = earthMesh.position.z + mr * Math.sin(moonAng);
  moon.position.y = earthMesh.position.y + Math.sin(moonAng) * 6;
  
  moon.label.position.copy(moon.position);
  moon.label.position.y += 14;

  // Rotate zodiac slowly
  zodiacGroup.rotation.y += 0.00028;

  // Update sight lines from observation point
  if (showLines) {
    sightLines.forEach(l => scene.remove(l)); 
    sightLines = [];
    
    const observationPoint = isGeocentric ? new THREE.Vector3(0, 0, 0) : earthPos;
    
    // Draw lines from observation point to each celestial body
    planets.concat([{mesh: moon, data:{name:"Moon"}}]).forEach(obj => {
      if (isGeocentric && obj.data.name === "Earth") return;
      if (!isGeocentric && obj.data.name === "Sun") return;
      
      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          observationPoint,
          obj.mesh.position
        ]),
        new THREE.LineBasicMaterial({color:0xffdd88, transparent:true, opacity:0.4})
      );
      scene.add(line);
      sightLines.push(line);
    });
    
    // Line to Sun in geocentric mode
    if (isGeocentric) {
      const sunLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          observationPoint,
          sunMesh.position
        ]),
        new THREE.LineBasicMaterial({color:0xffdd88, transparent:true, opacity:0.4})
      );
      scene.add(sunLine);
      sightLines.push(sunLine);
    }
  }

  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}

// Toggle View Mode
document.getElementById('toggle-view').addEventListener('click', function() {
  isGeocentric = !isGeocentric;
  this.classList.toggle('heliocentric', !isGeocentric);
  this.classList.toggle('geocentric', isGeocentric);
  this.textContent = isGeocentric ? 
    "Geocentric Mode â€“ Click to Switch to Heliocentric" : 
    "Heliocentric Mode â€“ Click to Switch to Geocentric";

  // Adjust camera for better view
  if (isGeocentric) {
    camera.position.set(0, 140, 550);
  } else {
    camera.position.set(260, 320, 450);
  }
  controls.target.set(0, 0, 0);
  controls.update();
});

// Other toggles
document.getElementById('toggle-labels').addEventListener('click', function() {
  showLabels = !showLabels;
  planets.forEach(p => p.label.visible = showLabels);
  sunMesh.label.visible = showLabels;
  moon.label.visible = showLabels;
  this.classList.toggle('on', showLabels);
  this.textContent = `Labels: ${showLabels ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-orbits').addEventListener('click', function() {
  showOrbits = !showOrbits;
  orbits.forEach(o => o.visible = showOrbits);
  this.classList.toggle('on', showOrbits);
  this.textContent = `Orbits: ${showOrbits ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-lines').addEventListener('click', function() {
  showLines = !showLines;
  if (!showLines) {
    sightLines.forEach(l => scene.remove(l));
    sightLines = [];
  }
  this.classList.toggle('on', showLines);
  this.textContent = `Sight Lines: ${showLines ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-zodiac').addEventListener('click', function() {
  showZodiac = !showZodiac;
  zodiacGroup.visible = showZodiac;
  this.classList.toggle('on', showZodiac);
  this.textContent = `Zodiac: ${showZodiac ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-stars').addEventListener('click', function() {
  showStars = !showStars;
  starField.visible = showStars;
  this.classList.toggle('on', showStars);
  this.textContent = `Stars: ${showStars ? 'ON' : 'OFF'}`;
});

document.getElementById('toggle-chart').addEventListener('click', function() {
  showChart = !showChart;
  document.getElementById('chart-overlay').style.display = showChart ? 'block' : 'none';
  this.classList.toggle('on', showChart);
  this.textContent = `Chart: ${showChart ? 'ON' : 'OFF'}`;
});

function setSpeed(v) {
  timeScale = v;
  document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('on'));
  event.target.classList.add('on');
}

function togglePause() {
  isPaused = !isPaused;
  document.getElementById('pause-btn').textContent = isPaused ? 'Resume' : 'Pause';
}

function resetView() {
  camera.position.set(isGeocentric ? 0 : 260, 320, isGeocentric ? 550 : 450);
  controls.target.set(0, 0, 0);
  controls.update();
}
</script>
</body>
</html>
